# 大小端

---

### **大端**：数据的高字节存放在高位内存地址，低字节存放在高位内存地址中。x86 CPU，像电脑一般都是大端的

### **小端**：数据的高字节存放在地位内存地址，高字节存放在高位内存地址中。arm CPU，如STM32, 手机SOC等都是小端

>> 例如：16进制数0x0123456789的存储：
>> | 内存地址 | 0x4007 | 0x4008 | 0x4009 | 0x400A | 0x400B |
>>|---|---|---|---|---|---|
>> | 大端模式 | 0x01 | 0x23 | 0x45 | 0x67 | 0x89 |
>> | 小端模式 | 0x89 | 0x67 | 0x45 | 0x23 | 0x01 |

### 在不同设备进行数据传输时要注意两个设备处于那种模式，如果一个从处于小端模式的设备传数据给处于大端模式的设备（或者反过来操作）会造成数据的混乱

## **大小端转换**

>可以用位运算或者使用char*读取后重组
>>例：1、使用位运算（将小端模式转为大端模式）：
>>>uint32 Reverse32(uint32 x){
&emsp;&emsp;return ((x&0x000000ff) << 24) | ((x&0x0000ff00) << 8) | ((x&0x000000ff) &emsp;&emsp;>> 8) | ((x&0xff000000) >> 24);
}

>>解析：以((x&0x000000ff) << 24) 为例，x是一个占四个字节的整形变量，共占有32为二进制数，将x与0x000000ff进行与运算，可以得出x的低位字节的数，将它左移24位后就可以得到x的高位字节的数，其他的位运算与此同理。

>>例：2、使用char*读取后重组：
>>>uint32 Reverse32(uint32 x)
{
&emsp;int i;
&emsp;char*temp[4];
&emsp;for(i = 0;i < 4;i++){
&emsp;&emsp;&emsp;temp[i] = (char*)(&x) + i;
&emsp; }
 &emsp;return ((*temp\[3\]<<24)|(\*temp\[2\]<<16)|(\*temp\[1\]<<8)|\*temp\[0\]);
}
>>解析：利用取地址运算符&获得存放x每个字节的内存地址，将地址中的数据按字节重组后输出。
